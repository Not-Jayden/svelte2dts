/* eslint-disable @typescript-eslint/unbound-method */
import fs from 'fs'
import path from 'path'
import ts from 'typescript'
import sv2tsx from 'svelte2tsx'
import { relativePath ,relPathJson } from './utils'

interface TsxMapping {
  code: string
  dest: string
  componentPath: string
  dtsCode?: string
  autoGenerated?: boolean
}
type TsxMap = Record<string ,TsxMapping>

function generateTsx(srcPath:string ,strictMode: boolean) {
  const file = fs.readFileSync(srcPath)
  // Generate the tsx code for the component
  const { code: tsxCode } = sv2tsx(file.toString('utf-8') ,{
    filename: srcPath
    // Assume true.
    // May need to parse it ourselves instead of using svelte2tsx
    // Since they do not look at lang tag
    // and lang can be different between script/module tags.
    ,isTsFile: true
    // Assume true. If false, the usefullness of ts drops by 75%.
    ,strictMode
  })

  const shimmedCode = '/// <reference types="svelte2tsx/svelte-shims" />\n'
  + '/// <reference types="svelte2tsx/svelte-jsx" />\n'
  + `${tsxCode}`

  return shimmedCode
}

function shouldCreateVirtual(componentPath: string) {
  // Only create declarations if a conflicting typing file does not exist.
  let typedPath = `${componentPath}.ts`
  if (fs.existsSync(typedPath)) {
    throw new Error(`Ts file ${relPathJson(typedPath)} conflicts with ${relPathJson(componentPath)}.`)
  }

  typedPath = `${componentPath}.tsx`
  if (fs.existsSync(typedPath)) {
    throw new Error(`Tsx file ${relPathJson(typedPath)} conflicts with ${relPathJson(componentPath)}.`)
  }

  typedPath = `${componentPath}.d.ts`
  if (fs.existsSync(typedPath)) return false

  // No typings exists. Safe to generate!
  return true
}

interface RetType {
  extraFiles: TsxMap
  tsxMap: TsxMap
}

// Runs on multiple components at a time to reduce wasted cycles.
// shouldGenerateTypings = (filePath)=>filePath.endsWith('.svelte')
export function generateComponentDeclarations(
  componentPaths: string[]
  ,srcDir: string
  ,outDir: string
  ,strictMode: boolean
  ,shouldGenerateTypings: (filePath:string)=>boolean = () => false
): RetType {
  const genTsxPath = (filePath:string) => `${filePath}.tsx`
  const genTsxMapping = (filePath: string) => ({
    code: generateTsx(filePath ,strictMode)
    ,dest: `${path.resolve(outDir)}${filePath.slice(path.resolve(srcDir).length)}.d.ts`
    ,componentPath: filePath
  } as TsxMapping)

  // Keep up with tsx->d.ts conversion paths
  const tsxMap: TsxMap = {}

  // Generate tsx files
  for (const compPath of componentPaths) {
    // eslint-disable-next-line no-continue
    if (!shouldCreateVirtual(compPath)) continue
    // Write to a tsx file. Required by ts createProgram
    const tsxOutPath = genTsxPath(compPath)
    tsxMap[tsxOutPath] = genTsxMapping(compPath)
  }

  // Generate d.ts files
  const extraFiles = compileTsDeclaration(tsxMap ,{
    declaration: true
    ,emitDeclarationOnly: true
  } ,(filePath ,fileExists) => {
    // FIXME: This is contrived. Steal whatever code ts is using to loop fileExist instead
    // Only claim tsx files
    if (!filePath.endsWith('.tsx')) return

    const componentPath = filePath.replace(/\.tsx$/ ,'')
    // Only claim tsx files which refers to a file in the fs
    if (!fileExists(componentPath)) return

    // Only claim files we are interested in (like .svelte files)
    if (!shouldGenerateTypings(componentPath)) return

    if (!shouldCreateVirtual(componentPath)) return

    // Only claim files in src dir
    if (!filePath.startsWith(srcDir)) return

    // If we made it here, then we want to create a virtual file!
    tsxMap[filePath] = genTsxMapping(filePath.replace(/\.tsx$/ ,''))
    tsxMap[filePath].autoGenerated = true
  })
  return {
    tsxMap ,extraFiles
  }
}

function compileTsDeclaration(files: TsxMap
  ,options: ts.CompilerOptions
  ,autoVirtual: (filePath:string
    ,fileExist: ts.CompilerHost['fileExists'])=>void = () => {}) {
  // Create a Program with an in-memory emit
  const host = ts.createCompilerHost(options)
  const extraFiles: TsxMap = {}
  host.writeFile = (fileName ,contents) => {
    const file = Object.values(files).find((e) => e.componentPath === fileName.replace(/\.d\.ts/ ,''))
    if (file !== undefined) {
      file.dtsCode = contents
    }
    else {
      const extraFile = Object.values(extraFiles).find((e) => e.dest === fileName)
      if (extraFile !== undefined) {
        extraFile.dtsCode = contents
      }
    }
  }
  const originalReadFile = host.readFile
  const originalFileExists = host.fileExists
  host.fileExists = (filePath) => {
    // Attempt to auto-create virtuals
    if (files[filePath] === undefined) {
      autoVirtual(filePath ,(somePath) => originalFileExists.call(host ,somePath))
    }
    // Logging
    // const asVirtual = files[filePath]?.code !== undefined
    // if (!filePath.includes('node_modules')) console.log('Checking existence of...',relativePath(filePath), asVirtual ? 'virtual' : originalFileExists.call(host,filePath))

    if (files[filePath] === undefined && originalFileExists.call(host ,filePath)) {
      const pathRe = /\.(?:ts|tsx|js|jsx|d\.ts)$/
      if (pathRe.test(filePath)) {
        const newPath = filePath.replace(pathRe ,'.d.ts')
        extraFiles[newPath] = {
          code: ''
          ,componentPath: filePath
          ,dest: newPath
        }
      }
    }
    return files[filePath] !== undefined || originalFileExists.call(host ,filePath)
  }
  host.readFile = (filePath) =>
    // const asVirtual = files[filePath]?.code !== undefined
    // if (!filePath.includes('node_modules')) console.log(`Reading${asVirtual ? ' (virtual)' : ''}...`,relativePath(filePath))
    files[filePath]?.code ?? originalReadFile.call(host ,filePath)

  // Prepare the contents for the d.ts files
  let runs = 1
  const maxAttempts = 5
  while (runs === 1 || (
    Object.values(files).some((e) => e.autoGenerated) && runs <= maxAttempts
  )) {
    const targetFiles = runs === 1 ? Object.keys(files) : Object.entries(files)
      .filter(([,e]) => e.autoGenerated)
      .map(([k]) => k)
    console.log(`--- ${runs > 1 ? 'Re-' : ''}Running TS (attempt: ${runs}) ---`)
    if (runs > 1) {
      console.log('Covering missed files'
        ,Object.values(files)
          .filter((e) => e.autoGenerated)
          .map((e) => relativePath(e.componentPath)))
    }
    // Un-mark any auto generated files
    Object.values(files).forEach((e) => {
      if (e.autoGenerated === true) e.autoGenerated = false
    })

    // Run ts
    // FIXME: There is a better way to loop this.
    // Maybe using .emit(fileName), or possible using languageServices.
    const programFix = ts.createProgram(targetFiles ,options ,host)
    const checker = programFix.getTypeChecker()
    const sourceFiles = programFix.getSourceFiles()
    for (const sourceFile of sourceFiles) {
      if (!Object.keys(files).includes(sourceFile.fileName)) continue
      ts.forEachChild(sourceFile ,(node) => {
        if (ts.isClassDeclaration(node)
        && node.modifiers?.some((e) => e.kind === ts.SyntaxKind.ExportKeyword) === true
        && node.modifiers?.some((e) => e.kind === ts.SyntaxKind.DefaultKeyword) === true
        ) {
          const someType = node.heritageClauses?.[0].types[0]
          if (someType !== undefined && someType.kind === ts.SyntaxKind.ExpressionWithTypeArguments) {
            const componentType = checker.getTypeAtLocation(someType)
            const typeString = checker.typeToString(componentType)
            const oldCode = files[sourceFile.fileName].code
            files[sourceFile.fileName].code = oldCode.slice(0 ,someType.pos + 1)
            + typeString
            + oldCode.slice(someType.end)
          }
        }
      })
    }
    const programEmit = ts.createProgram(targetFiles ,options ,host)
    programEmit.emit()

    // Increment run counter
    runs++
  }
  return extraFiles
}
/*
function visit(node: ts.Node) {
  // Only consider exported nodes
  if (!node) {
    return
  }

  if (ts.isClassDeclaration(node) && node.name) {
    // This is a top level class, get its symbol
    const symbol = checker.getSymbolAtLocation(node.name)
    if (symbol) {
      output.push(serializeClass(symbol))
    }
    // No need to walk any further, class expressions/inner declarations
    // cannot be exported
  }
  else if (ts.isModuleDeclaration(node)) {
    // This is a namespace, visit its children
    ts.forEachChild(node ,visit)
  }
}
*/
